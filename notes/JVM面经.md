## Java内存模型

![image-20220310152741343](JVM面经/image-20220310152741343.png)

JDK 8 版本 本地方法区被Metaspace(元空间)取代

JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是**元空间，元空间使用的是直接内存。**

运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)



**线程私有的：**

- 程序计数器
- 虚拟机栈
- 本地方法栈（native方法）

**线程共享的：**

- 堆
- 方法区
- 直接内存 (非运行时数据区的一部分)



Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表（基本数据类型 、引用）、操作数栈、动态链接、方法出口信息。

本地方法栈则为虚拟机使用到的 Native 方法服务

Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。

方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。





## Java中创建对象都做了什么事情

Person p = new Person("zhangsan",20);

该句话都做了什么事情？

1，因为new用到了Person.class.所以会先找到Person.class文件并加载到内存中。

2，执行该类中的static代码块，如果有的话，给Person.class类进行初始化。

3，在堆内存中开辟空间，分配内存地址。

4，在堆内存中建立对象的特有属性。并进行默认初始化。

5，对属性进行显示初始化。

6，对对象进行构造代码块初始化。

7，对对象进行对应的构造函数初始化。

8，将内存地址付给栈内存中的p变量

Java中创建对象的内存图
![Java中创建对象的内存图_内存地址_02](https://s7.51cto.com/images/blog/202109/28/48c1739b5732f675fc01403e0144707f.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=)



![Java中创建对象的内存图_.net_03](https://s5.51cto.com/images/blog/202109/28/fc992e9d315ba1e02940e2772df7dc42.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=)





## Java对象创建过程 五步

**1 类加载检查**

检查这个符号引用代表的类是否已被加载过、解析和初始化过。

**2 分配内存**

分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。

而 Java 堆内存是否规整，取决于 GC 收集器的算法是"标记-清除"，还是"标记-整理"（也称作"标记-压缩"）

**3 初始化零值**

**4 设置对象头**

初始化零值完成之后，**虚拟机要对对象进行必要的设置**，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 **这些信息存放在对象头中。**

**5 执行 init 方法**

执行 new 指令之后会接着执行 `<init>` 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。



### 对象的访问定位

建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，

目前主流的访问方式有

**① 使用句柄**

 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息

![对象的访问定位-使用句柄](https://javaguide.cn/assets/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D-%E4%BD%BF%E7%94%A8%E5%8F%A5%E6%9F%84.aa7060e3.png)

**② 直接指针**

如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。

![对象的访问定位-直接指针](https://javaguide.cn/assets/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D-%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88.9bfd6702.png)

**这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。**





## 类的生命周期

一个类的完整生命周期如下：

![img](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B-%E5%AE%8C%E5%96%84.png)





## 类加载过程

系统加载 Class 类型的文件主要三步：**加载->连接->初始化**。连接过程又可分为三步：**验证->准备->解析**。

![img](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png)

###  加载

类加载过程的第一步，主要完成下面 3 件事情：

1. 通过全类名获取定义此类的二进制字节流
2. 将字节流所代表的静态存储结构转换为方法区的运行时数据结构
3. 在内存中生成一个代表该类的 `Class` 对象，作为方法区这些数据的访问入口



所有的类都由类加载器加载，加载的作用就是将 `.class`文件加载到内存。



### 验证

![验证阶段示意图](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E9%AA%8C%E8%AF%81%E9%98%B6%E6%AE%B5.png)

### 准备

准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。



### 解析

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。



### 初始化

当遇到 `new` 、 `getstatic`、`putstatic` 或 `invokestatic` 这 4 条直接码指令时，对类进行初始化



##  卸载

卸载类即该类的 Class 对象被 GC。

卸载类需要满足 3 个要求:

1. 该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。
2. 该类没有在其他任何地方被引用
3. 该类的类加载器的实例已被 GC





## 垃圾回收（重点）

针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：

部分收集 (Partial GC)：

- 新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；
- 老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；
- 混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。

整堆收集 (Full GC)：收集整个 Java 堆和方法区。



## 如何对象已经死亡

- 引用计数法

给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。

- 可达性分析算法 引用链

通过一系列的称为 **“GC Roots”** 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。



## 垃圾回收算法

**1 标记-清除算法**

标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象

**2 标记-复制算法**

将内存分为大小相同的两块, 当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉

**3 标记-整理算法**

根据老年代的特点提出的一种标记算法, 让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。

**4 分代收集算法**

当前虚拟机的垃圾收集都采用分代收集算法,  一般将 java 堆分为新生代和老年代,  在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法, 

老年代的对象存活几率是比较高的，没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。



## 垃圾收集器

1. **Serial 收集器**

单线程收集器,新生代采用标记-复制法，老年代采用标记-整理法。

2. **ParNew 收集器**

Serial 收集器的多线程版本, 新生代采用标记-复制法，老年代采用标记-整理法。

3. **Parallel Scavenge 收集器**

Parallel Scavenge 收集器也是使用标记-复制算法的多线程收集器, **这是 JDK1.8 默认收集器**

4. **Serial Old 收集器**

5. **Parallel Old 收集器**

**Parallel Scavenge 收集器的老年代版本**。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。

6. **CMS 收集器**

CMS 收集器是一种 **“标记-清除”算法**实现的

7. **G1 收集器**

8. **ZGC 收集器**







