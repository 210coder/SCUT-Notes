# ACID **隔离的原子 一致的持久**

**隔离性** 并发事务互不影响
**原子性** 事务的操作要么都执行，要么都不执行。

**一致性** 保持数据库的约束完整性

**持久性** 事务发生了，对数据库的影响是持久的，不会回滚。

#### MyISAM和InnoDB区别

#### InnoDB支持行锁 支持事务 支持外键 支持MVCC 支持崩溃后的安全恢复

**InnoDB**也支持表级锁 但MyISAM只支持表级锁

**MyISAM**强调的是性能，每次查询具有原子性,其执行速度比InnoDB类型更快

# MVCC 多版本并发控制

- MVCC是被Mysql中`事务型存储引擎InnoDB`所支持的;
- **应对高并发事务, MVCC比`单纯的加锁`更高效**;
- MVCC只在`READ COMMITTED`和`REPEATABLE READ`两个隔离级别下工作;
- MVCC可以使用`乐观(optimistic)锁`和`悲观(pessimistic)锁`来实现;
- 各数据库中MVCC实现并不统一

# 数据库事务隔离级别-- 脏读、不可重复读、幻读

数据库事务的隔离级别有4个，由低到高依次为Read uncommitted 、Read committed 、Repeatable read 、Serializable ，这四个级别可以逐个解决脏读 、不可重复读 、幻读 这几类问题。

### 脏读（读取未提交数据）

A事务读取B事务尚未提交的数据，此时如果B事务发生错误并执行回滚操作，那么A事务读取到的数据就是脏数据。

### 不可重复读（前后多次读取，数据内容不一致）

事务A在执行读取操作，由整个事务A比较大，前后读取同一条数据需要经历很长的时间 。而在事务A第一次读取数据，比如此时读取了小明的年龄为20岁，事务B执行更改操作，将小明的年龄更改为30岁，此时事务A第二次读取到小明的年龄时，发现其年龄是30岁，和之前的数据不一样了，也就是数据不重复了，系统不可以读取到重复的数据，成为不可重复读。

### 幻读（前后多次读取，数据总量不一致）

事务A在执行读取操作，需要两次统计数据的总量，前一次查询数据总量后，此时事务B执行了新增数据的操作并提交后，这个时候事务A读取的数据总量和之前统计的不一样，就像产生了幻觉一样。

### 不可重复读和幻读到底有什么区别呢？

（1）不可重复读是读取了其他事务更改的数据，针对insert与update操作

解决：使用行级锁，锁定该行，事务A多次读取操作完成后才释放该锁，这个时候才允许其他事务更改刚才的数据。

 

（2）幻读是读取了其他事务新增的数据，针对insert与delete操作

解决：使用表级锁，锁定整张表，事务A多次读取数据总量之后才释放该锁，这个时候才允许其他事务新增数据。

![](C:\Users\祥仔\AppData\Roaming\marktext\images\2019-09-01-12-52-21-image.png)

### 读未提交（Read Uncommitted）

- 在一个事务中可以读取到另一个事务中新增或修改但未提交的数据。
- 该隔离级别可能导致的问题是脏读。因为另一个事务可能回滚，所以在第一个事务中读取到的数据很可能是无效的脏数据，造成脏读现象。

### 读已提交（Read Committed）

一个事务只能看见已经提交事务所做的修改。

### 可重复读（Repeatable Read）

- 这是MySQL的默认事务隔离级别
- 它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。通俗来讲，可重复读在一个事务里读取数据，怎么读都不会变，除非提交了该事务，再次进行读取。
- 该隔离级别存在的问题是幻读。

### 串行化（Serializable）

- 它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。通俗地讲就是，假如两个事务都操作到同一数据行，那么这个数据行就会被锁定，只允许先读取/操作到数据行的事务优先操作，只有当事务提交了，数据行才会解锁，后一个事务才能成功操作这个数据行，否则只能一直等待

- 该隔离级别可能导致大量的超时现象和锁竞争。
