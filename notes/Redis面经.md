参考
[link](https://javaguide.cn/database/redis/redis-questions-01/)

**Redis 6.2.6 is the latest stable version**

6379



Redis分布式缓存 集群的主从复制 实现读写分离 六个节点的应用实例



关于社交网络分析系统的Redis 集群介绍

社交网络系统使用1.8的版本

Redis集群 6个节点的 三主三从 复制Redis文件 配置端口不一样就行

在项目的redis.properties文件中新增集群机器的配置，将6个节点依次加入配置

在ssm+maven项目中集成redis很简单，只需要引入redis客户端（redis.clients redis连接工具）和spring对redis的支持的jar包（spring-data-redis），引入redis的相关配置就可以了

![image-20220313201810178](Redis面经/image-20220313201810178.png)

直接注入jedisCluster获取一个集群对象

**jedisCluster.set(key,value)**

![image-20220313201706907](Redis面经/image-20220313201706907.png)



**jedisCluster.get(key)**

![image-20220313201511466](Redis面经/image-20220313201511466.png)



## Redis是什么
简单来说 Redis 就是一个使用 C 语言开发的，开源的高性能key-value非关系缓存数据库，不过与传统数据库不同的是 Redis 的数据是存在内存中的 ，也就是它是内存数据库，所以读写速度非常快，每秒可以处理超过 10万次读写操作，因此 Redis 被广泛应用于缓存方向。

另外，Redis 除了做分布式缓存之外，也经常用来做分布式锁，甚至是消息队列。

Redis 提供了多种数据类型（字符串、列表、集合、散列表、有序集合 zset）来支持不同的业务场景。Redis 还支持事务 、持久化、Lua 脚本、多种集群方案。



## Redis用途 应用场景
- 分布式缓存：性能key-value非关系**缓存数据库** 支持集群模式 集群的主从复制模型
- 分布式锁 ： 通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 Redisson 来实现分布式锁。
-  限流 ：一般是通过 Redis + Lua 脚本的方式来实现限流。
- 消息队列 ：Redis 自带的 list 数据结构可以作为一个简单的队列使用。Redis5.0 中增加的 Stream 类型的数据结构更加适合用来做消息队列。它比较类似于 Kafka，有主题和消费组的概念，支持消息持久化以及 ACK 机制。 
- 复杂业务场景 ：通过 Redis 以及 Redis 扩展（比如 Redisson）提供的数据结构，我们可以很方便地完成很多复杂的业务场景比如通过 bitmap 统计活跃用户、通过 sorted set 维护排行榜。 如排行榜 计算器应用



## Redis 常见数据类型以及使用场景分析

5种 String List Hash Set Sorted set

- string
Redis自己构建了一种 简单动态字符串（simple dynamic string，SDS）
相比于 C 的原生字符串，Redis 的 SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)（C 字符串为 O(N)）
应用场景： 一般常用在需要计数的场景，比如**用户的访问次数、热点文章的点赞转发数量**等等。string自增自减实现计数器



- list
  Redis 的 list 的实现为一个 双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。
  应用场景: 发布与订阅或者说消息队列、慢查询。

- hash

  hash 类似于 JDK1.8 前的 HashMap，内部实现也差不多(数组 + 链表)。

  hash 是一个 string 类型的 field 和 value 的映射表，特别适合用于存储对象，内部实现类似于数组+链表，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以 hash 数据结构来存储用户信息，商品信息等等。
  应用场景: 系统中对象数据的存储。

- set
set 类似于 Java 中的 HashSet 
应用场景: 需要存放的数据不能重复以及需要获取多个数据源交集和并集等场景，
比如：你可以将一个用户**所有的关注人存在一个集合**中，将其**所有粉丝存在一个集合**。Redis 可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。

- sorted set
和 set 相比，sorted set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，还可以通过 score 的范围来获取元素的列表。
应用场景： 需要对数据根据某个权重进行排序的场景。比如在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的**消息排行榜**）等信息。

实现原理：

- bitmap
  bitmap 存储的是连续的二进制数字（0 和 1），通过 bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 bitmap 本身会极大的节省储存空间。
  应用场景： 适合需要保存状态信息（比如是否签到、是否登录...）并需要进一步对这些信息进行分析的场景。比如用户签到情况、活跃用户情况、用户行为统计（比如是否点赞过某个视频）。



## Redis 数据结构

**字典**

[link](https://www.jianshu.com/p/bfecf4ccf28b)

1. 在Redis中，Redis数据库就是使用字典来作为底层实现的，Redis的字典使用**哈希表**作为底层实现。

2. 以**链地址法**的方式解决键冲突问题，多个哈希值相同的键值对连接在一起**，**程序总是将新节点添加到链表的表头位置（这样添加节点的时间复杂度为O(1)）**。

3. Redis 的字典 dict 中包含两个哈希表 dictht，这是为了方便进行 rehash 操作。在扩容时，将其中一个 dictht 上的键值对 rehash 到另一个 dictht 上面，完成之后释放空间并交换两个 dictht 的角色。

**rehash**

rehash 操作不是一次性完成，而是采用**渐进方式**，这是为了避免一次性执行过多的 rehash 操作给服务器带来过大的负担。

这样做的目的是，如果服务器中包含很多键值对，要一次性的将这些键值对全部rehash到ht[1]的话，庞大的计算量可能导致服务器在一段时间内停止服务于。

渐进式 rehash 通过记录 dict 的 **rehashidx** 完成，它从 0 开始，然后每执行一次 rehash 都会递增。例如在一次 rehash 中，要把 dict[0] rehash 到 dict[1]，这一次会把 dict[0] 上 table[rehashidx] 的键值对 rehash 到 dict[1] 上，dict[0] 的 table[rehashidx] 指向 null，并令 rehashidx++。

在 rehash 期间，每次对字典执行添加、删除、查找或者更新操作时，都会执行一次渐进式 rehash。

字典的删除、查找、更新等操作都是在两个表上进行的。

例如，**查找**操作会先在ht[0]上进行，如果没找到再在ht[1]上进行。

**添加**操作的键值对会一律保存到ht[1]中，这一措施保证ht[0]包含的键值对只会减少不会增加。

采用渐进式 rehash 会导致字典中的数据分散在两个 dictht 上，因此对字典的查找操作也需要到对应的 dictht 去执行。



哈希表结构

![image-20220312194415990](Redis面经/image-20220312194415990.png)

table属性是一个**数组**，数组中的每个元素都指向一个dictEntry结构的指针，每个dictEntry结构保存着一个键值对。

**以拉链法的方式解决冲突问题，多个哈希值相同的键值对连接在一起**

![image-20220312200408867](Redis面经/image-20220312200408867.png)



**跳跃表**

是有序集合的底层实现之一。

跳跃表是基于**多指针有序链表**实现的，可以看成多个有序链表。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/beba612e-dc5b-4fc2-869d-0b23408ac90a.png)

在查找时，从上层指针开始查找，找到对应的区间之后再到下一层去查找。

与红黑树等平衡树相比，跳跃表具有以下优点：

- 插入速度非常快速，因为不需要进行旋转等操作来维护平衡性；
- 更容易实现；
- 支持无锁操作







## Redis 单线程模型

先讲这个：

Redis 基于 Reactor 模式开发了自己的网络事件模型，使用 I/O 多路复用程序来同时监听多个套接字，并将到达的事件传送给文件事件分派器，分派器会根据套接字产生的事件类型调用相应的事件处理器。

由于**文件事件处理器**（file event handler）是单线程方式运行的，所以我们一般都说 Redis 是单线程模型。



文件事件处理器（file event handler）主要是包含 4 个部分：

- 多个 socket（客户端连接）
- IO 多路复用程序（支持多个客户端连接的关键）
- 文件事件分派器（将 socket 关联到相应的事件处理器）
- 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9ea86eb5-000a-4281-b948-7b567bd6f1d8.png)

**Redis 通过IO 多路复用程序 来监听来自客户端的大量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型（读、写）注册到内核中并监听每个事件是否发生。**

 **I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗。**

**后来Redis6.0后引入多线程是为了提高网络 IO 读写性能**。



 Redis 服务器是一个事件驱动程序，服务器需要处理两类事件：1. 文件事件; 2. 时间事件。

文件事件就是上面说的文件事件处理器



## Redis多线程知识
- Redis 4.0加入了对多线程的支持，增加的多线程主要是针对一些大键值对的删除操作的命令，使用这些命令就会使用主处理之外的其他线程来“异步处理”。
- Redis 6.0 之前主要还是单线程处理


-  **Redis6.0 引入多线程主要是为了提高网络 IO 读写性能，但是Redis 的瓶颈主要受限于内存和网络。**
- Redis6.0 引入了多线程，但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了，**执行命令仍然是单线程顺序执行**。因此，你也不需要担心线程安全问题。
- Redis6.0 的多线程默认是禁用的，只使用主线程。如需开启需要修改 redis 配置文件 redis.conf，且还需要设置线程数，否则是不生效的。



redis.conf配置文件
>io-threads-do-reads yes
>io-threads 4 #官网建议4核的机器建议设置为2或3个线程，8核的建议设置为6个线程



## Redis6.0 之前 为什么不使用多线程
1. 单线程编程容易并且更容易维护；
2. Redis 的性能瓶颈不在 CPU ，主要在内存和网络；
3. 多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。

**但后来Redis6.0后引入多线程是为了提高网络 IO 读写性能**。



## Redis 给缓存数据设置过期时间的作用
- 因为内存是有限的，如果缓存中的所有数据都是一直保存的话，分分钟直接 Out of memory
- 很多时候，我们的业务场景就是需要某个数据只在某一时间段内存在, 短信验证码可能只在 1 分钟内有效，用户登录的 token 可能只在 1 天内有效。

## Redis 是如何判断数据是否过期的
Redis 通过一个叫做**过期字典（可以看作是 hash 表）**来保存数据过期的时间。过期字典的键指向 Redis 数据库中的某个 key(键)，过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）。

过期字典是存储在 redisDb 这个结构里的
![在这里插入图片描述](https://img-blog.csdnimg.cn/305313f3c25944eba9a46c6a74c43496.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2O5Y2X5bCP5ZOl,size_20,color_FFFFFF,t_70,g_se,x_16)



## 过期的数据的删除策略

- **惰性删除** ：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。 
- **定期删除** ： 每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。 定期删除对内存更加友好，惰性删除对 CPU 更加友好。

两者各有千秋，所以 Redis 采用的是 定期删除+惰性删除 。

但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就 Out of memory 了。

怎么解决这个问题呢？答案就是：**Redis 内存淘汰机制**。





## Redis 内存淘汰机制
allkey LRU LFU Random
volatile LRU LFU Random
再加两个
noeviction 写入报错
volatile ttl 有更早过期时间的key优先移除

Redis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。

**全局的key选择性移除**
- noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。
- allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。（*LRU 是最常用的**）
- allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。

**设置过期时间的key选择性移除**

- volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。
- volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。
- volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。

4.0 版本后增加以下两种： 

- volatile-lfu（least frequently used）：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰 
- 
- allkeys-lfu（least frequently used）：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key

这里Redis的内存淘汰策略的选取并不会影响过期的key的处理。内存淘汰策略是用于处理内存不足时的需要申请额外空间的数据；而过期策略用于处理过期的缓存数据。





## Redis 持久化机制(怎么保证 Redis 挂掉之后再重启数据可以进行恢复)

- Redis 默认的一种持久化方式叫**快照**（snapshotting，RDB）
Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本，产生的数据文件为dump.rdb。

- 另一种方式是**只追加文件**（append-only file, AOF）
则是将Redis执行的每次写命令记录到单独的日志文件中，当重启Redis会重新将持久化的日志中文件恢复数据。当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复。

开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到内存缓存 server.aof_buf 中，然后再根据 appendfsync 配置来决定何时将其同步到硬盘中的 AOF 文件。

在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：
>appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度
appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘
appendfsync no        #让操作系统决定何时进行同步

**Redis 4.0 开始支持 RDB 和 AOF 的混合持久化, AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。**



## Redis 事务
- Redis 事务提供了一种将多个命令（MULTI，EXEC，DISCARD 和 WATCH）请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。
- Redis的事务和数据库的ACID事务不一样
**Redis 是不支持 roll back 的，因而不满足原子性的（而且不满足持久性）。**



## Redis 除了做分布式缓存，还能做什么
- **分布式锁** ： 通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 Redisson 来实现分布式锁。
- **限流** ：一般是通过 Redis + Lua 脚本的方式来实现限流。 
- **消息队列** ：Redis 自带的 list 数据结构可以作为一个简单的队列使用。Redis5.0 中增加的 Stream 类型的数据结构更加适合用来做消息队列。它比较类似于 Kafka，有主题和消费组的概念，支持消息持久化以及 ACK 机制。 
- **复杂业务场景** ：通过 Redis 以及 Redis 扩展（比如 Redisson）提供的数据结构，我们可以很方便地完成很多复杂的业务场景比如通过 bitmap 统计活跃用户、通过 sorted set 维护排行榜。


## Redis分布式锁

## 分布式缓存常见的技术选型方案有哪些？
分布式缓存的话，使用的比较多的主要是 Memcached 和 Redis。



## Redis 和 Memcached 的区别和共同点
- 共同点 ： 
	1. 都是基于内存的数据库，一般都用来当做缓存使用。 
	2.  都有过期策略。 
	3.  两者的性能都非常高。 
- 区别 ： 
1. **Redis 支持更丰富的数据类型（支持更复杂的应用场景）**。Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。Memcached 只支持最简单的 k/v 数据类型。 
2. **Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memcached 把数据全部存在内存之中**。 
3. **Redis 有灾难恢复机制**。 因为可以把缓存中的数据持久化到磁盘上。 
4. Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached 在服务器内存使用完之后，就会直接报异常。 
5. **Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 cluster 模式的**。 
6. **Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型**。 （Redis 6.0 引入了多线程 IO ） 
7. **Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。并且，Redis 支持更多的编程语言**。 
8. **Memcached 过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。**



记住这个：

Redis支持五种数据类型，Memcached只支持string。

Redis支持RDB AOF持久化  Memcached不支持持久化，把数据保存在内存中

所以Redis 有灾难恢复机制，Memcached没有。

Redis支持分布式集群，Memcached依靠客户端来实现往集群中分片写入数据

Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型

Memcached 过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除，可以为每个键设置过期时间。



## 为什么要用 Redis/为什么要用缓存？
主要从“高性能”和“高并发”这两点来看待这个问题。
- 高性能
假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在数缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！
- 高并发
直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。



## 保证 Redis 缓存与数据库双写一致性？ 缓存一致性

[link](https://mp.weixin.qq.com/s?__biz=MzIyOTYxNDI5OA==&mid=2247487312&idx=1&sn=fa19566f5729d6598155b5c676eee62d&chksm=e8beb8e5dfc931f3e35655da9da0b61c79f2843101c130cf38996446975014f958a6481aacf1&scene=178&cur_album_id=1699766580538032128#rd)

数据一致性问题

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3OezNCibL5S9oyeYqJBQVZCo8ic8WbuqDQcJ2bVyia7t9rOu9CGyJnCkWQs16WNibAwdV0GbH3q0K6ZMw/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)

- 写请求依旧只写数据库
- 读请求先读缓存，如果缓存不存在，则从数据库读取，并重建缓存
- 同时，写入缓存中的数据，都设置失效时间

所以，当数据发生更新时，我们不仅要操作数据库，还要一并操作缓存。具体操作就是，修改一条数据时，不仅要更新数据库，也要连带缓存一起更新。

但数据库和缓存都更新，又存在先后问题，那对应的方案就有 2 个：

1. 先更新缓存，后更新数据库
2. 先更新数据库，后更新缓存

  **1) 先更新缓存，后更新数据库**

如果缓存更新成功了，但数据库更新失败，那么此时缓存中是最新值，但数据库中是「旧值」。

虽然此时读请求可以命中缓存，拿到正确的值，但是，一旦缓存「失效」，就会从数据库中读取到「旧值」，重建缓存也是这个旧值。

**2) 先更新数据库，后更新缓存**

如果数据库更新成功了，但缓存更新失败，那么此时数据库中是最新值，缓存中是「旧值」。

之后的读请求读到的都是旧数据，只有当缓存「失效」后，才能从数据库中得到正确的值。

「更新数据库 + 更新缓存」的方法在多线程并发上会出现不一致 错误的问题



**所以要采用删除缓存的策略**

[链接](https://segmentfault.com/a/1190000039078249)

​	**3）先删除缓存，后更新数据库**
![在这里插入图片描述](https://img-blog.csdnimg.cn/474c3938769244b8bcf7f796227cbdd7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2O5Y2X5bCP5ZOl,size_20,color_FFFFFF,t_70,g_se,x_16)
就会产生数据库和 Redis 数据不一致
解决办法 **延时双删的策略**
![在这里插入图片描述](https://img-blog.csdnimg.cn/832d008749f14aaea7c9a43f45d54f71.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2O5Y2X5bCP5ZOl,size_20,color_FFFFFF,t_70,g_se,x_16)
但是上述的保证事务提交完以后再进行删除缓存还有一个问题，就是如果你使用的是 Mysql 的读写分离的架构的话，那么其实主从同步之间也会有时间差。

此时的解决办法就是如果是对 Redis 进行填充数据的查询数据库操作，那么就强制将其指向主库进行查询。
![在这里插入图片描述](https://img-blog.csdnimg.cn/fcea64f2bc734192982b8ea55a55ea99.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2O5Y2X5bCP5ZOl,size_20,color_FFFFFF,t_70,g_se,x_16)

**4）先更新数据库，后删除缓存**
这一种情况也会出现问题，比如更新数据库成功了，但是在删除缓存的阶段出错了没有删除成功，那么此时再读取缓存的时候每次都是错误的数据了。



解决方案就是利用消息队列进行删除的补偿
![在这里插入图片描述](https://img-blog.csdnimg.cn/2d4a99f33a024ba199a6be6aa6df22cc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2O5Y2X5bCP5ZOl,size_20,color_FFFFFF,t_70,g_se,x_16)
这个方案会有一个缺点就是会对**业务代码**造成大量的侵入，深深的耦合在一起，所以这时会有一个优化的方案，我们知道对 Mysql 数据库更新操作后再 binlog 日志中我们都能够找到相应的操作，那么我们可以**订阅 Mysql 数据库的 binlog 日志**对缓存进行操作。

拿 MySQL 举例，当一条数据发生修改时，MySQL 就会产生一条变更日志（Binlog），我们可以订阅这个日志，拿到具体操作的数据，然后再根据这条数据，去删除对应的缓存。

![在这里插入图片描述](https://img-blog.csdnimg.cn/3cb18a49f2df4357b791f298bed59664.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2O5Y2X5bCP5ZOl,size_17,color_FFFFFF,t_70,g_se,x_16)







记住这个：

1. **先更新数据库，后删除缓存，一定程度上可以保证数据一致性。**

![image-20220313205628557](Redis面经/image-20220313205628557.png)



	2. **删除缓存可能失败，利用消息队列进行删除的补偿。**
	3. **消息队列 业务代码耦合，近年来流行的方案，订阅数据库变更日志Binlog，再操作缓存**。



不能保证缓存和数据库「强一致」，做到强一致，最常见的方案是 2PC、3PC、Paxos、Raft 这类一致性协议，但它们的性能往往比较差，而且这些方案也比较复杂，还要考虑各种容错问题。

引入缓存是为了提高性能，要在性能和一致性做权衡。

当然我们可以通过加「分布锁」的方式来实现，但我们要付出的代价，很可能会超过引入缓存带来的性能提升。



## Redis集群模式

**Redis 支持三种集群方案**

- 主从复制模式
- Sentinel（哨兵）模式
- Cluster 模式



**主从复制模式**

主数据库可以进行读写操作，当写操作导致数据变化时会自动将数据同步给从数据库。而从数据库一般是只读的，并接受主数据库同步过来的数据。一个主数据库可以拥有多个从数据库，而一个从数据库只能拥有一个主数据库。

**总结：引入主从复制机制的目的有两个**

- 一个是读写分离，分担 "master" 的读写压力
- 一个是方便做容灾恢复



**哨兵模式**

哨兵模式是一种特殊的模式，首先 Redis 提供了哨兵的命令，**哨兵是一个独立的进程，作为进程，它会独立运行。其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个 Redis 实例**。

**哨兵模式的作用**

- 通过发送命令，让 Redis 服务器返回监控其运行状态，包括主服务器和从服务器；
- 当哨兵监测到 master 宕机，会自动将 slave 切换成 master ，然后通过**发布订阅模式**通知其他的从服务器，修改配置文件，让它们切换主机；



**Cluster 集群模式**

Redis 的哨兵模式基本已经可以实现高可用，读写分离 ，但是在这种模式下每台 Redis 服务器都存储相同的数据，很浪费内存，所以在 redis3.0上加入了 Cluster 集群模式，实现了 Redis 的分布式存储，**也就是说每台 Redis 节点上存储不同的内容**。



Redis 集群的主从复制模型

为了保证高可用，redis-cluster集群引入了主从复制模型，一个主节点对应一个或者多个从节点，当主节点宕机的时候，就会启用从节点。

redis-cluster**投票容错机制**：Redis 之间通过互相的 ping-pong 判断是否节点可以连接上。如果有一半以上的节点去ping 一个节点的时候没有回应，集群就认为这个节点宕机了，然后去连接它的从节点(必须主备模式)。



分布式缓存应该指的就是Redis 集群的主从复制模型 ？



## 什么是缓存穿透、缓存击穿、缓存雪崩

### 缓存穿透
大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。举个例子：某个黑客故意制造我们缓存中不存在的 key 发起大量请求，导致大量请求落到数据库。
这个请求的数据可能也不在数据库中 

### 如何避免缓存穿透
- 1.如果是非法请求，我们在API入口，对参数进行校验，过滤非法值。
- 2.如果查询数据库为空，我们可以给缓存设置个空值，或者默认值。但是如有有写请求进来的话，需要更新缓存哈，以保证缓存一致性，同时，最后给缓存设置适当的过期时间。（业务上比较常用，简单有效）
- 3.使用布隆过滤器快速判断数据是否存在。即一个查询请求过来时，先通过布隆过滤器判断值是否存在，存在才继续往下查。

布隆过滤器原理：它由初始值为0的位图数组和N个哈希函数组成。一个对一个key进行N个hash算法获取N个值，在比特数组中将这N个值散列后设定为1，然后查的时候如果特定的这几个位置都为1，那么布隆过滤器判断该key存在。

## 缓存雪奔
指缓存中数据大批量到过期时间，而查询数据量巨大，请求都直接访问数据库，引起数据库压力过大甚至down机。

出现场景：
举个例子：系统的缓存模块出了问题比如宕机导致不可用。造成系统的所有访问，都要走数据库。 
还有一种缓存雪崩的场景是：有一些被大量访问数据（热点缓存）在某一时刻大面积失效，导致对应的请求直接落到了数据库上。

### 解决办法
**针对 Redis 服务不可用的情况： **
- 采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。
- 限流，避免同时处理大量的请求。 

**针对热点缓存失效的情况：**
- 设置不同的失效时间比如随机设置缓存的失效时间。 
- 缓存永不失效。


### 缓存击穿
指热点key在某个时间点过期的时候，而恰好在这个时间点对这个Key有大量的并发请求过来，从而大量的请求打到db。

缓存击穿看着有点像，其实它两区别是，缓存雪奔是指数据库压力过大甚至down机，缓存击穿只是大量并发请求到了DB数据库层面。

### 解决办法
1. **使用互斥锁方案**。缓存失效时，不是立即去加载db数据，而是先使用某些带成功返回的原子操作命令，如(Redis的setnx）去操作，成功的时候，再去加载db数据库数据和设置缓存。否则就去重试获取缓存。
2. **“永不过期”**，是指没有设置过期时间，但是热点数据快要过期时，异步线程去更新和设置过期时间。


## 什么是热Key问题，如何解决热key问题
什么是热Key问题？

在Redis中，我们把访问频率高的key，称为热点key
如果某一热点key的请求到服务器主机时，由于请求量特别大，可能会导致主机资源不足，甚至宕机，从而影响正常的服务。

如何解决热key问题？
- Redis集群扩容：增加分片副本，均衡读流量；
- 将热key分散到不同的服务器中；
- 使用二级缓存，即JVM本地缓存,减少Redis的读请求。





## Redis 实现高可用 解决单点问题有两种方式

（1）Redis集群

好处：主节点崩了，从节点替换。读写分离。

1.  **主备方式**
   **一台主机、一台或多台备机，在正常情况下主机对外提供服务，并把数据同步到备机，当主机宕机后，备机立刻开始服务。**
   Redis HA中使用比较多的是keepalived，它使主机备机对外提供同一个虚拟IP，客户端通过虚拟IP进行数据操作，正常期间主机一直对外提供服务，宕机后VIP自动漂移到备机上。

优点是对客户端毫无影响，仍然通过VIP操作。
缺点也很明显，在绝大多数时间内备机是一直没使用，被浪费着的。

2. **主从方式**
   这种采取一主多从的办法，**主从之间进行数据同步**。 当Master宕机后，通过选举算法(Paxos、Raft)从slave中选举出新Master继续对外提供服务，主机恢复后以slave的身份重新加入。
   主从另一个目的是进行读写分离，这是当单机读写压力过高的一种通用型解决方案。 其主机的角色只提供写操作或少量的读，把多余读请求通过**负载均衡**算法分流到单个或多个slave服务器上。

![image-20220308105016451](Redis面经/image-20220308105016451.png)

缺点是主机宕机后，Slave虽然被选举成新Master了，但对外提供的IP服务地址却发生变化了，意味着会影响到客户端。 解决这种情况需要一些额外的工作，在当主机地址发生变化后及时通知到客户端，客户端收到新地址后，使用新地址继续发送新请求。

（2）数据同步
无论是主备还是主从都牵扯到数据同步的问题，这也分2种情况：

同步方式：当主机收到客户端写操作后，以同步方式把数据同步到从机上，当从机也成功写入后，主机才返回给客户端成功，也称数据强一致性。 很显然这种方式性能会降低不少，当从机很多时，可以不用每台都同步，主机同步某一台从机后，从机再把数据分发同步到其他从机上，这样提高主机性能分担同步压力。 在redis中是支持这杨配置的，一台master，一台slave，同时这台salve又作为其他slave的master。

异步方式：主机接收到写操作后，直接返回成功，然后在后台用异步方式把数据同步到从机上。 这种同步性能比较好，但无法保证数据的完整性，比如在异步同步过程中主机突然宕机了，也称这种方式为数据弱一致性。

**Redis主从同步采用的是异步方式，因此会有少量丢数据的危险。还有种弱一致性的特例叫最终一致性**，这块详细内容可参见CAP原理及一致性模型。



## Redis分布式缓存 

就是分布式集群的意思 根据不同的业务部署多个集群 通过代理访问真实的Redis服务器进行读写。









## Redis分布式锁
