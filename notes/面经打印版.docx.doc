计算机网络
1 浏览器输入URL
1. 浏览器根据DNS协议找到域名对应的IP地址
2. 浏览器与服务器三次握手建立TCP连接
3. 发送HTTP请求
4. 服务器处理请求并返回HTTP报文
5. 浏览器解析渲染页面
6. 连接结束

2 DNS 的解析过程？
1. 浏览器搜索 自己的DNS缓存
2. 若没有，则搜索操作系统中的DNS缓存和hosts文件
3. 若没有，则操作系统将域名发送至 本地域名服务器，本地域名服务器查询自己的DNS缓存，
   查找成功则返回结果，否则依次向根域名服务器、顶级域名服务器、权限域名服务器发起查询请求，最终返回IP地址给本地域名服务器
4. 本地域名服务器将得到的IP地址返回给操作系统，同时自己也将IP地址缓存起来
5. 操作系统将 IP 地址返回给浏览器，同时自己也将IP地址缓存起来
6. 浏览器得到域名对应的IP地址

3 Http状态码
200 OK 
204 和200差不多，但没有响应体body数据
301 永久重定向 302 临时重定向
404 Not Found
403 Forbidden
401 Unauthorized
504 Gateway Timeout 网关超时
503 Service Unavailable 表示服务器当前很忙，暂时无法响应服务器。

4 TCP 协议如何保证可靠传输
检验和 流量控制 拥塞控制 超时传输
拥塞控制
慢启动 拥塞避免 快重传 快恢复

5 三次握手的过程：
客户端的连接请求：首先客户端发送一个带 SYN 标志位的连接请求到服务器，客户端进入 SYN-SENT 状态。
服务端的连接确认请求：服务器收到之后回复一个 SYN 和 ACK 的确认报文到客户端，此时服务端进入 SYN-RECV 状态，等待第三次握手。
客户端的连接确认请求：客户端接收到确认报文后，向服务端再次发出带 ACK 的确认报文，后客户端这边连接建立，服务端收到客户端的第三次确认报文后，连接建立。

6 四次挥手的过程
客户端发送一个带 FIN 标志位的关闭连接请求，此时客户端进入 FIN - WAIT - 1 阶段。
服务器收到该请求后，返回一个 ACK, 进入ClOSE-WAIT阶段。
客户端收到 ACK 之后，进入 FIN - WAIT - 2 阶段，此时处于半关闭状态，服务器能给客户端发消息，但客户端不能给服务器发消息。
当服务器把剩下的消息发完之后，会发送一个 带 FIN 标志位的关闭连接请求给客户端，进入LAST-ACK阶段。
客户端收到该请求后，发出 ACK 确认，并进入最后的 TIME - WAIT 状态，等待 2MSL（最大报文存活时间） 后释放连接。
B 收到确认后，释放连接。

7. ping 命令的过程：
   主要为了测试两个主机间是否是通的！
- 如果在一个网段：
  - 首先主机 A 要向主机 B 发送 ICMP 回声请求报文，会先在 ARP 缓存表里找主机 B 的 IP 对应的 MAC 地址、
  - 如果有直接发送，如果没有，则发送一个 ARP 请求。
  - 主机 B 收到 ARP 请求之后，回复一个 ARP 应答。这样主机 A 就拿到了主机 B 的 MAC 地址。
  - 然后主机 A 发送 ICMP 回声请求报文，主机 B 接收到以后，回复一个 ICMP 回答报文。
  - 主机 A 根据回答报文估算往返时间和丢包率等等等。
- 如果不在同一个网段
  - 还是先找 MAC 地址
  - 如果有直接发送，没有的话，发送 ARP 请求到网关。
  - 网关收到 ARP 请求后，也会在自己的 ARP 缓存表里找是否有，没有的话就广播 ARP 请求，
    如果是一对一那就直接找下一跳。具体情况具体分析！（这里看王道考研 ARP 协议）反正就记住，如果不在同一个网段，就直接交给路由器处理。
  - 主机 B 收到 ARP 请求之后，把 MAC 地址告诉主机 A
  - 主机 A 发送 ICMP 回声请求报文，主机 B 接到之后，回复一个 ICMP 回答报文。
  - 根据回答报文估算往返时间，丢包率等


数据库
事务的特性
隔离性 原子性 一致性 持久性
数据库事务的隔离级别：
Read uncommitted 
Read committed 
Repeatable read 
Serializable 
这四个级别可以逐个解决脏读 、不可重复读 、幻读 这几类问题。

MVCC是什么
MVCC的目的就是多版本并发控制，在数据库中的实现，就是为了解决`读写冲突`，
它的实现原理主要是依赖记录中的 `3个隐式字段`，`undo日志` ，`Read View` 来实现的。
InnoDB储引擎中的锁都有哪些类型？
可以分为共享锁、排他锁、意向锁、一致性非锁定读和一致性锁定读。
Mysql三大日志
二进制日志 binlog（归档日志）和事务日志 redo log（重做日志）和 undo log（回滚日志）
MyISAM和InnoDB区别
- InnoDB支持行锁 支持事务 支持外键 支持MVCC 支持崩溃后的安全恢复
- InnoDB也支持表级锁 但MyISAM只支持表级锁

为什么B+树比B树更适合实现数据库索引？
范围区间查询
减少IO
查询稳定

数据库的主从复制
主从复制是指数据可以从一个MySQL数据库服务器主节点复制到一个或多个从节点。
主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。

操作系统
进程控制块 (Process Control Block, PCB) 
描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对PCB 的操作, PCB 是进程存在的唯一标识。
- PCB包含
  - 进程的描述信息，
  - 处理机的状态信息

进程和线程的区别 关系
资源 调度 系统开销 创建销毁进程 通信
- 首先从资源来说，进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。
- 然后从调度来说，线程是独立调度的基本单位，在同一进程中线程切换的话不会引起进程的切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程的切换。
- 从系统开销来讲，由于创建或撤销进程，系统都要分配回收资源，所付出的开销远大于创建或撤销线程时的开销。类似的，在进行进程切换的时候，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境设置，而线程切换只需保存和设置少量寄存器的内容，开销很小。
- 通信方面来说，线程间可以通过直接读写同一进程的数据进行通信，但是进程通信需要借助一些复杂的方法。

进程间通信的方式
管道/匿名管道：用于具有亲缘关系有名管道：
消息队列
内存共享
信号量
套接字

线程间同步的方式
互斥量：持有“互斥量（就是锁）”的线程才有访问公共资源的权限。
信号量：允许同一时刻多个线程访问统一资源，但是需要控制最大线程数量。
事件：wait/notify 通过通知保证多线程同步

页面置换算法
最佳置换算法
先进先出页面置换算法
LRU
时钟置换算法（CLOCK）
LFU

阻塞IO，即在读写数据的过程中会发生阻塞现象。
非阻塞IO模型中，用户线程需要不断地询问内核数据是否就绪(这种方式称为轮询 polling)
在异步IO模型中，当用户线程发起read操作之后，立刻就可以开始去做其它的事。
在多路复用IO模型中
使用 select 或者 poll 等待数据，会有一个线程不断去轮询多个socket的状态，只有当某一个socket真正有读写事件时，才真正调用实际的IO读写操作。
信号驱动IO（signal driven IO）
在信号驱动IO模型中，当用户线程发起一个IO请求操作，注册信号函数，在信号函数中调用IO读写操作来进行实际的IO请求操作。

select 允许应用程序监视一组文件描述符，等待一个或者多个描述符成为就绪状态，从而完成 I/O 操作。
poll 的功能与 select 类似，也是等待一组描述符中的一个成为就绪状态。
epoll只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且进程不需要通过轮询来获得事件完成的描述符。

进程的调度算法
先来先服务
短作业优先
最短作业优先
时间片轮转
优先级调度
多级反馈队列

synchronized是java提供的一个原子性内置锁，线程的执行代码在进入synchronized代码块时会自动获取到内部锁（java内置的使用者看不到的锁），也叫监视器锁，其他线程访问该同步代码块时会被阻塞挂起。synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。
总结：
同步代码块
通过monitorenter与monitorexit指令获取和释放对象的监控器锁( monitor )
同步方法
当线程执行到方法后会检查是否有ACC_SYNCHRONIZED这个标志，有的话隐式去调用monitorenter与monitorexit指令，也是对监控器锁的获取和释放
JDK1.6 对锁的实现引入了大量的优化，锁粗化、锁消除、锁升级如偏向锁、轻量级锁、自旋锁、适应性自旋锁等技术来减少锁操作的开销。
锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。
volatile具有内存可见性、有序性，不具备原子性。
对比
volatile 关键字是线程同步的轻量级实现，所以 volatile性能肯定比synchronized关键字要好 。volatile不会让线程阻塞，响应速度比synchronized高，但是 volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块 。
volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。
volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。


























