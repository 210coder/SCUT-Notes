## TCP/IP四层协议

- **应用层**

**应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。**

域名系统**DNS**，支持万维网应用的**HTTP协议**，支持电子邮件的**SMTP协议**

- **运输层**

**运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务**。

1. **传输控制协议 TCP**（Transmission Control Protocol）--提供**面向连接**的，**一对一的**，**可靠的**，面向**字节流**的数据传输服务，**效率低**。

TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源

1. **用户数据协议 UDP**（User Datagram Protocol）--提供**无连接**的，**多对多的**，**不可靠的**尽最大努力的，面向**数据报文段**的数据传输服务，**效率高**。

![](C:\Users\祥仔\AppData\Roaming\marktext\images\2019-08-31-23-34-13-image.png)

## TCP 协议如何保证可靠传输

**检验和 流量控制 拥塞控制 超时传输**

1. 应用数据被分割成 TCP 认为最适合发送的数据块。
2. TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。
3. **校验和**：TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。
4. TCP 的接收端会丢弃重复的数据。
5. **流量控制**：TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。（TCP 利用滑动窗口实现流量控制）

接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。

1. **拥塞控制**：为了进行拥塞控制，TCP 发送方要维持一个拥塞窗口(cwnd)的状态变量。

拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。

TCP的拥塞控制采用了四种算法，即**慢开始**、**拥塞避免**、**快重传**和**快恢复**

1. **ARQ协议**：也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。
2. **超时重传**：当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。

## 在浏览器中输入url地址 ->> 显示主页的过程(面试常客)

百度好像最喜欢问这个问题。

> 打开一个网页，整个过程会使用哪些协议

图解（图片来源：《图解HTTP》）：

![](C:\Users\祥仔\AppData\Roaming\marktext\images\2019-09-01-01-36-01-image.png)

总体来说分为以下几个过程:

1. 浏览器根据DNS协议找到域名对应的IP地址
2. 浏览器与服务器三次握手建立TCP连接
3. 发送HTTP请求
4. 服务器处理请求并返回HTTP报文
5. 浏览器解析渲染页面
6. 连接结束

# HTTP状态码

![](C:\Users\祥仔\AppData\Roaming\marktext\images\2019-09-01-01-47-59-image.png)

200 请求成功，返回数据体。

202 服务器接收了请求，但还没处理。

404 请求失败 请求的资源未在服务器找到

401 请求要求身份验证

403  服务器理解请求，但拒绝执行它

500 服务器遇到了一个未曾预料的情况，导致它无法完成对请求的处理。

503 由于临时服务器维护或过载，无法处理请求，这个是临时的。

304 请求的网页未修改过，不返回网页内容，返回此响应。

# GET和POST

**安全可见 缓存长度书签 历史后退**

| 分类       | GET                                                              | POST                                                                  |
|:-------- | ---------------------------------------------------------------- | --------------------------------------------------------------------- |
| 后退按钮/刷新  | 无害                                                               | 数据会被重新提交（浏览器应该告知用户数据会被重新提交）。                                          |
| 书签       | 可收藏为书签                                                           | 不可收藏为书签                                                               |
| 缓存       | 能被缓存                                                             | 不能缓存                                                                  |
| 编码类型     | application/x-www-form-urlencoded                                | application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。 |
| 历史       | 参数保留在浏览器历史中。                                                     | 参数不会保存在浏览器历史中。                                                        |
| 对数据长度的限制 | 是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。    | 无限制。                                                                  |
| 对数据类型的限制 | 只允许 ASCII 字符。                                                    | 没有限制。也允许二进制数据。                                                        |
| 安全性      | 与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！ | POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。                           |
| 可见性      | 数据在 URL 中对所有人都是可见的。                                              | 数据不会显示在 URL 中。                                                        |

# 三次握手和四次挥手

![](C:\Users\祥仔\AppData\Roaming\marktext\images\2019-09-01-02-22-11-image.png)

- 客户端–发送带有 SYN 标志的数据包–一次握手–服务端
- 服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端
- 客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端

第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常

第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常

第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常

所以三次握手就能确认双发收发功能都正常，缺一不可。

![](C:\Users\祥仔\AppData\Roaming\marktext\images\2019-09-01-02-22-29-image.png)

断开一个 TCP 连接则需要“四次挥手”：

- 客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送
- 服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号
- 服务器-关闭与客户端的连接，发送一个FIN给客户端
- 客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1

### 为什么要四次挥手

任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。

举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。
