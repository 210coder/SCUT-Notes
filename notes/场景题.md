

## 海量10G数据找出中位数，内存2G

https://zhuanlan.zhihu.com/p/75397875

思路一：外排序（排序-归并）

外排序就是由于数据量太大不能一次性加载到内存，所以需要先暂时用外存储器（硬盘）将数据存起来，然后依次读入一部分数据到内存，排序之后，生成临时文件存储到硬盘，最后再对这些临时文件进行一个归并，得到最后的排序结果（在合并的过程中虽然不需要多大内存，但是会产生频繁的IO操作，频繁的读磁盘和写磁盘）



思路二：堆排序（转换为求前5G大的元素）

**最大堆求前n小，最小堆求前n大。**

1、前k小：构建一个k个数的**最大堆**，当读取的数大于根节点时，舍弃；当读取的数小于根节点时，替换根节点，重新塑造最大堆，然后继续读取，最后读取完所有的数据之后，最大堆中的数就是最小k个数

2、前k大：构建一个k个数的**最小堆**，当读取的数小于根节点时舍弃；当读取的数大于根节点时，替换根节点，重新塑造最小堆，然后继续读取，读取完所有的数据之后，最小堆中的数就是最大k个数



建立一个1g个整数的最大值堆，如果元素小于最大值则入堆，这样可以得到第1g大的那个元素然后利用这个元素，重新建一次堆，这次入堆的条件除了小于最大值还要加上大于这个第1g大的元素，这样建完堆可以得到第2g大的那个...



思路三：二进制位比较 快速排序的分割思想

基于二进制位将10G数据映射到不同的文件中，利用快速排序的分割思想寻找中位数。

依次读入一部分数据到内存，根据数据的最高位将数据映射到不同的文件中，然后判断中位数可能存在于于哪个文件然后再继续对哪个文件进行分割，知道能够将数据读入内存直接排序。

基于二进制比较 将数字使用二进制表示 比较二进制的最高位 划分到两个不同的文件

如此反复操作 直到可以将划分的小文件读到内存中 再使用快速排序比较

https://blog.csdn.net/qq_41306849/article/details/119828746

该方法相对于外排序和堆排序可以减少磁盘IO的次数，每次可以丢弃一部分数据不再进行读取和写入操作



思路四：基数排序（计数排序）

思路五：桶排序

思路六：bitmap位图算法





## 技术书籍

凤凰架构 周志明



为什么读这个本书



## 微服务





## 负载均衡





### JSR303自定义参数验证

使用JSR303自定义校验器，实现对用户账号、密码的验证，使得验证逻辑从业务代码中脱离出来。







